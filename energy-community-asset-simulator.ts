/** 
* This template file was generated by the bifrost-sdk.
* Edit the init and update functions to create business logic
for your module. 
*/ 
import  { 
    DataFrame, 
    TModuleContext, 
    TState,
    Log
        } from 'bifrost-zero-common'
import  { 
    localStorageType,
    TYPEID,
    typeLocalStorage, 
        } from './src/types.js';
import  { BifrostZeroModule } from 'bifrost-zero-sdk'
import  { TYPEID_LOCAL } from './data/fragment/local_types.js';
import * as fs from 'fs';
import csv from 'csv-parser';
import { unescape } from 'querystring';

async function readCSVtoDict(filePath: string): Promise<{ [key: string]: any }> {
    return new Promise((resolve, reject) => {
        fs.createReadStream(filePath)
            .pipe(csv({separator: ";", }))
            .on('data', (row) => {
                const timestamp = row.Time;
                const [hours, minutes, seconds] = timestamp.split(':').map(Number);
                delete row.Time; // Remove the timestamp column from the row object
                const convertedTs = hours*3600 + minutes*60 + seconds
                const numericRow: Record<string, number> = {};
                Object.keys(row).forEach(key => {
                numericRow[key] = parseFloat(row[key]);
                if (isNaN(numericRow[key])) {
                    numericRow[key] = 0; // or any default value, or keep as null/undefined
                }
                });
                csvData[convertedTs] = numericRow;
            })
            .on('end', () => {
                resolve(csvData);
            })
            .on('error', (err) => {
                reject(err);
            });
    });
}

const localStorage : typeLocalStorage = {}
const csvData: { [key: string]: any } = {};

const logic = { 

    initFn: (storyId: string, experimentId: string, state: TState, context: TModuleContext) => { 
        
        context.log.write(`Init from [${storyId}/${experimentId}]`)
        
        // initialize the local storage for this experiment
        localStorage[experimentId] = {
            allPGCs: [],
            byPGC: {}
        }	
        try {

            for (const pgcId of state.structures.ids){
                const entity = state.structures.entities[pgcId]
                if(entity.typeId === TYPEID.PGC){
                    if(entity.experimentId === experimentId){
                        localStorage[experimentId].allPGCs.push(pgcId)
                        localStorage[experimentId].byPGC[pgcId] = {
                            pgcApId: "",
                            pgcRpId: "",
                            chpApId: "",
                            hbatApId: "",
                            pvApId: "",
                            pvMaxApId: "",
                            evApId: "",
                            evMaxApId: ""
                        }
                        // get apId of pgc
                        const pgcDynIds:string[] = entity.dynamicIds
                        for (const dynId of pgcDynIds){
                            if (state.dynamics.entities[dynId].typeId == TYPEID.ACTIVE_POWER){
                                localStorage[experimentId].byPGC[pgcId].pgcApId = dynId
                            }
                            if (state.dynamics.entities[dynId].typeId == TYPEID.REACTIVE_POWER){
                                localStorage[experimentId].byPGC[pgcId].pgcRpId = dynId
                            }
                        }
                        // get childIds
                        const pgcChildIds:string[] = entity.childIds
                        for (const childId of pgcChildIds){
                            const dynIds = state.structures.entities[childId]?.dynamicIds
                            if (dynIds === undefined){
                                continue
                            }
                            if (state.structures.entities[childId].typeId == TYPEID.SOLAR_PANEL){
                                for (const dynId of dynIds){
                                    if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.PV_SYSTEM_POWER){
                                        localStorage[experimentId].byPGC[pgcId].pvApId = dynId
                                    }
                                    if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.PV_SYSTEM_MAX_POWER){
                                        localStorage[experimentId].byPGC[pgcId].pvMaxApId = dynId
                                    }
                                }
                            }else if (state.structures.entities[childId].typeId == TYPEID.CHARGING_POLE){
                                for (const dynId of dynIds){
                                    if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.CHGSTATION_POWER){
                                        localStorage[experimentId].byPGC[pgcId].evApId = dynId
                                    }
                                    if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.CHGSTATION_MAX_POWER){
                                        localStorage[experimentId].byPGC[pgcId].evMaxApId = dynId
                                    }
                                }
                            }else if (state.structures.entities[childId].typeId == TYPEID.CHP_STACK){
                                for (const dynId of dynIds){
                                    if (state.dynamics.entities[dynId].typeId == TYPEID.ACTIVE_POWER){
                                        localStorage[experimentId].byPGC[pgcId].chpApId = dynId
                                        break
                                    }
                                }
                            }else if (state.structures.entities[childId].typeId == TYPEID.HOUSEHOLD_BAT){
                                for (const dynId of dynIds){
                                    if (state.dynamics.entities[dynId].typeId == TYPEID.ACTIVE_POWER){
                                        localStorage[experimentId].byPGC[pgcId].hbatApId = dynId
                                        break
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } catch (error) {
            context.log.write(`Error in init ${error}`, Log.level.ERROR)
        }
        
        return new DataFrame()
    },

    updateFn: (storyId: string, experimentId: string, startAt:number, simulationAt: number, replayAt: number, data: DataFrame, context: TModuleContext) => {
        context.log.write(`Update from [${storyId}/${experimentId}] @ ${simulationAt}`)
        // extract subscriptionData out of dataFrame
        var dynamicsById = {}
        if(!data.isEmpty()){
            for (const dynamicObj of data.series) {
                dynamicsById[dynamicObj.dynamicId] = dynamicObj.values[0]
            }
        }
        const result: DataFrame = new DataFrame()
        result.setTime(simulationAt)

        try {
            //  time modulo so day repeats
            const dataTime = (startAt + simulationAt) % 86400
            const wData = csvData[dataTime]
            // summer/winter
            let SW = ""
            if (startAt > 6739200 && startAt < 22809600){
                SW = "S"
            }else{
                SW = "W"
            }
            for (const pgcId of localStorage[experimentId].allPGCs){
                const pStruct = localStorage[experimentId].byPGC[pgcId]
                let sumLoad = 0
                if(pStruct.chpApId){
                    const CHP_3 = [wData["CHP-"+SW]/3,wData["CHP-"+SW]/3,wData["CHP-"+SW]/3]
                    sumLoad += wData["CHP-"+SW]
                    result.addSeries({dynamicId:pStruct.chpApId,values:[CHP_3]})
                }
                if(pStruct.pvApId){
                    let pvInfeed = wData["PV-"+SW]/1000
                    if (-pvInfeed <= dynamicsById[pStruct.pvMaxApId]){
                        result.addSeries({dynamicId:pStruct.pvApId,values:[[-pvInfeed, -pvInfeed]]})
                    } else {
                        result.addSeries({dynamicId:pStruct.pvApId,values:[[-pvInfeed, dynamicsById[pStruct.pvMaxApId]]]})
                        pvInfeed = -dynamicsById[pStruct.pvMaxApId]
                    }
                    sumLoad += pvInfeed
                }
                if(pStruct.hbatApId){
                    sumLoad += wData["BAT-"+SW]
                    const HBAT_3 = [wData["BAT-"+SW]/3,wData["BAT-"+SW]/3,wData["BAT-"+SW]/3]
                    result.addSeries({dynamicId:pStruct.hbatApId,values:[HBAT_3]})
                }
                if(pStruct.evApId){
                    let chgPowerDemand = wData["EV"]
                    if (chgPowerDemand <= dynamicsById[pStruct.evMaxApId]){
                        result.addSeries({dynamicId:pStruct.evApId,values:[[wData["EV"], wData["EV"]]]})
                    } else {
                        result.addSeries({dynamicId:pStruct.evApId,values:[[wData["EV"], dynamicsById[pStruct.evMaxApId]]]})
                        chgPowerDemand = dynamicsById[pStruct.evMaxApId]
                    }
                    sumLoad += chgPowerDemand
                }
                // There is always at least  "normal" pgc load
                const resultLoad = (sumLoad/3)+(wData["LD-"+SW]/3)
                result.addSeries({dynamicId:pStruct.pgcApId,values:[[resultLoad,resultLoad,resultLoad]]})
            }
        } catch (error) {
            context.log.write(`Error: ${error}`, Log.level.ERROR)
        }
        
        return result
    }
}

const m = new BifrostZeroModule({
    author         : 'anonymous',
    label          : 'OpenSwarm Asset Simulator',
    about          : 'Module to simulate assest in OpenSwarm PoC1.',
    initCallback   : logic.initFn,
    updateCallback : logic.updateFn,
    fragmentFile   : './data/fragment/Module.Fragment.yaml',
    subscriptions  : [
        TYPEID_LOCAL.CHGSTATION_MAX_POWER,
        TYPEID_LOCAL.PV_SYSTEM_MAX_POWER
    ],
    samplingRate   : 900,
    docURL         : '',
    moduleURL      : process.env.MODULE_URL  || 'http://localhost:1808',
    bifrostURL     : process.env.BIFROST_URL || 'http://localhost:9091',
    hook           : [90]
})

const csvFilePath = 'data/csv/profile-data.csv';
readCSVtoDict(csvFilePath)
    .then(() => {
        m.context.log.write("Data loaded");
    })
    .catch((error) => {
        m.context.log.write('Error reading CSV:', error);
    });

m.start()