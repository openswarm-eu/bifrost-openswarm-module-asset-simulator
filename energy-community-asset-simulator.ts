/** 
* This template file was generated by the bifrost-sdk.
* Edit the init and update functions to create business logic
for your module. 
*/ 
import  { 
    DataFrame, 
    TModuleContext, 
    TState,
    Log
        } from 'bifrost-zero-common'
import  { 
    localStorageType,
    TYPEID, 
        } from './src/types.js'
import  { BifrostZeroModule } from 'bifrost-zero-sdk'
import  { 
    sensorNames, 
    TYPEID_LOCAL 
        } from './data/fragment/local_types.js'
import * as fs from 'fs'
import csv from 'csv-parser'

async function readCSVtoDict(filePath: string): Promise<{ [key: string]: any }> {
    return new Promise((resolve, reject) => {
        fs.createReadStream(filePath)
            .pipe(csv({separator: ";", }))
            .on('data', (row) => {
                const timestamp = row.Time;
                const [hours, minutes, seconds] = timestamp.split(':').map(Number);
                delete row.Time; // Remove the timestamp column from the row object
                const convertedTs = hours*3600 + minutes*60 + seconds
                const numericRow: Record<string, number> = {};
                Object.keys(row).forEach(key => {
                numericRow[key] = parseFloat(row[key]);
                if (isNaN(numericRow[key])) {
                    numericRow[key] = 0; // or any default value, or keep as null/undefined
                }
                });
                csvData[convertedTs] = numericRow;
            })
            .on('end', () => {
                resolve(csvData);
            })
            .on('error', (err) => {
                reject(err);
            });
    });
}

const localStorage : localStorageType = {}
const csvData: { [key: string]: any } = {};

const logic = { 

    initFn: (storyId: string, experimentId: string, state: TState, context: TModuleContext) => { 
        
        context.log.write(`Init from [${storyId}/${experimentId}]`)
        
        // initialize the result DataFrame of the init function
        const initResult: DataFrame = new DataFrame()
        initResult.setTime(0)
        
        // initialize the local storage for this experiment
        localStorage[experimentId] = {
            lastUpdate     : -1,
            numberUpdate   : 0,
            allPGCs        : [],
            byPGC          : {},
            allGridSensors : [],
            byGridSensor   : {}
        }	
        try {
            for (const structureId of state.structures.ids){
                const entity = state.structures.entities[structureId]
                if(entity.experimentId === experimentId){
                    
                    // get all needed information for the grid sensors
                    if(entity.typeId === TYPEID_LOCAL.GRID_SENSOR){
                        localStorage[experimentId].allGridSensors.push(structureId)
                        localStorage[experimentId].byGridSensor[structureId] = {
                            nameId             : "",
                            isActive           : false,
                            nodeVoltageId      : "",
                            cableCurrentId     : "",
                            powerMeasurementId : "",
                            powerLimitId       : ""
                        }
                        // get the sensor dynamicIds
                        const gridDynIds:string[] = entity.dynamicIds
                        for (const dynId of gridDynIds){
                            if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.GRID_SENSOR_NAME){
                                localStorage[experimentId].byGridSensor[structureId].nameId = dynId
                                // get the value of the sensor name
                                const sensorName = state.values.entities[dynId].value
                                // when sensor name is "Inactive" then set isActive to false
                                if (sensorName == sensorNames.INACTIVE){
                                    localStorage[experimentId].byGridSensor[structureId].isActive = false
                                } else { 
                                    localStorage[experimentId].byGridSensor[structureId].isActive = true
                                }
                            }else if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.GRID_SENSOR_POWERMEASUREMENT){
                                localStorage[experimentId].byGridSensor[structureId].powerMeasurementId = dynId
                            }else if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.GRID_SENSOR_POWERLIMIT){
                                localStorage[experimentId].byGridSensor[structureId].powerLimitId = dynId
                            }
                        }
                        // get now the dynamics of the needed values for calculation of the sensor measurements
                        const parentIds:string[] = entity.parentIds
                        for (const parentId of parentIds){
                            if (state.structures.entities[parentId].typeId == TYPEID.NODE){
                                const nodeEntity = state.structures.entities[parentId]
                                const nodeDynIds:string[] = nodeEntity.dynamicIds
                                for (const dynId of nodeDynIds){
                                    // get the voltage id of the node
                                    if (state.dynamics.entities[dynId].typeId == TYPEID.VOLTAGE){
                                        localStorage[experimentId].byGridSensor[structureId].nodeVoltageId = dynId
                                    }
                                }
                                // get the childs of the node
                                const nodeChildIds:string[] = nodeEntity.childIds
                                let cableCounter = 0
                                for (const childId of nodeChildIds){
                                    // skip non connnection entities
                                    if (state.connections.entities[childId] === undefined){
                                        continue
                                    }
                                    if (state.connections.entities[childId].typeId == TYPEID.CABLE){
                                        cableCounter++
                                        if (cableCounter > 2){
                                            // more than 2 cables connected to the node
                                            context.log.write(`Error: More than 2 cables connected to the node ${parentId}`, Log.level.ERROR)
                                            context.log.write(`Sensor ${localStorage[experimentId].byGridSensor[structureId].nameId} set to inactive`, Log.level.INFO)
                                            // set this sensor to inactive
                                            localStorage[experimentId].byGridSensor[structureId].isActive = false
                                            // set the sensor name to "Inactive"
                                            initResult.addSeries({dynamicId:localStorage[experimentId].byGridSensor[structureId].nameId,values:[sensorNames.INACTIVE]})
                                            continue
                                        }
                                        if (cableCounter > 1){
                                            continue
                                        }
                                        // get the cable current id of the cable
                                        const cableEntity = state.connections.entities[childId]
                                        const cableDynIds:string[] = cableEntity.dynamicIds
                                        for (const cableDynId of cableDynIds){
                                            if (state.dynamics.entities[cableDynId].typeId == TYPEID.CURRENT){
                                                localStorage[experimentId].byGridSensor[structureId].cableCurrentId = cableDynId
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    // get all needed information for the power grid connectors
                    if(entity.typeId === TYPEID.PGC){
                        localStorage[experimentId].allPGCs.push(structureId)
                        localStorage[experimentId].byPGC[structureId] = {
                            pgcApId   : "",
                            pvApId    : "",
                            pvMaxApId : "",
                            evApId    : "",
                            evMaxApId : ""
                        }
                        // get apId of pgc
                        const pgcDynIds:string[] = entity.dynamicIds
                        for (const dynId of pgcDynIds){
                            if (state.dynamics.entities[dynId].typeId == TYPEID.ACTIVE_POWER){
                                localStorage[experimentId].byPGC[structureId].pgcApId = dynId
                            }
                        }
                        // get childIds
                        const pgcChildIds:string[] = entity.childIds
                        for (const childId of pgcChildIds){
                            const dynIds = state.structures.entities[childId]?.dynamicIds
                            if (dynIds === undefined){
                                continue
                            }
                            if (state.structures.entities[childId].typeId == TYPEID_LOCAL.SOLAR_PANEL){
                                for (const dynId of dynIds){
                                    if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.PV_SYSTEM_POWER){
                                        localStorage[experimentId].byPGC[structureId].pvApId = dynId
                                    }
                                    if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.PV_SYSTEM_MAX_POWER){
                                        localStorage[experimentId].byPGC[structureId].pvMaxApId = dynId
                                    }
                                }
                            }else if (state.structures.entities[childId].typeId == TYPEID_LOCAL.CHARGING_POLE){
                                for (const dynId of dynIds){
                                    if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.CHGSTATION_POWER){
                                        localStorage[experimentId].byPGC[structureId].evApId = dynId
                                    }
                                    if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.CHGSTATION_MAX_POWER){
                                        localStorage[experimentId].byPGC[structureId].evMaxApId = dynId
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } catch (error) {
            context.log.write(`Error in init ${error}`, Log.level.ERROR)
        }
        
        return initResult
    },

    updateFn: (storyId: string, experimentId: string, startAt:number, simulationAt: number, replayAt: number, data: DataFrame, context: TModuleContext) => {
        context.log.write(`Update from [${storyId}/${experimentId}] @ ${simulationAt}`)
        // extract subscriptionData out of dataFrame
        var dynamicsById = {}
        if(!data.isEmpty()){
            for (const dynamicObj of data.series) {
                dynamicsById[dynamicObj.dynamicId] = dynamicObj.values[0]
            }
        }
        const result: DataFrame = new DataFrame()
        result.setTime(simulationAt)
        if (localStorage[experimentId].lastUpdate !== simulationAt){
            localStorage[experimentId].lastUpdate = simulationAt
            localStorage[experimentId].numberUpdate = 1
        } else {
            localStorage[experimentId].numberUpdate += 1
        }
        
        try {
            //  time modulo so day repeats
            const dataTime = (startAt + simulationAt) % 86400
            const wData = csvData[dataTime]
            
            // check, if summer or winter
            let SW = ""
            if (startAt > 6739200 && startAt < 22809600){
                SW = "S"
            }else{
                SW = "W"
            }
            
            // update asset values
            if (localStorage[experimentId].numberUpdate == 1){
                for (const pgcId of localStorage[experimentId].allPGCs){
                    const pStruct = localStorage[experimentId].byPGC[pgcId]
                    let sumLoad = 0

                    if(pStruct.pvApId){
                        let pvInfeed = wData["PV-"+SW]/1000
                        if (-pvInfeed <= dynamicsById[pStruct.pvMaxApId]){
                            result.addSeries({dynamicId:pStruct.pvApId,values:[[-pvInfeed, -pvInfeed]]})
                        } else {
                            result.addSeries({dynamicId:pStruct.pvApId,values:[[-pvInfeed, dynamicsById[pStruct.pvMaxApId]]]})
                            pvInfeed = -dynamicsById[pStruct.pvMaxApId]
                        }
                        sumLoad += pvInfeed
                    }

                    if(pStruct.evApId){
                        let chgPowerDemand = wData["EV"]
                        if (chgPowerDemand <= dynamicsById[pStruct.evMaxApId]){
                            result.addSeries({dynamicId:pStruct.evApId,values:[[wData["EV"], wData["EV"]]]})
                        } else {
                            result.addSeries({dynamicId:pStruct.evApId,values:[[wData["EV"], dynamicsById[pStruct.evMaxApId]]]})
                            chgPowerDemand = dynamicsById[pStruct.evMaxApId]
                        }
                        sumLoad += chgPowerDemand
                    }
                    
                    // calculate the resulting load value
                    const resultLoad = (sumLoad/3)
                    result.addSeries({dynamicId:pStruct.pgcApId,values:[[resultLoad,resultLoad,resultLoad]]})
                }
            }
            
            // update the grid sensor values
            if (localStorage[experimentId].numberUpdate == 2){
                for (const sensorId of localStorage[experimentId].allGridSensors){
                    const sStruct = localStorage[experimentId].byGridSensor[sensorId]
                    if (sStruct.isActive){
                        const nodeVoltage = dynamicsById[sStruct.nodeVoltageId]
                        const cableCurrent = dynamicsById[sStruct.cableCurrentId]
                        const powerLimit = dynamicsById[sStruct.powerLimitId]
                        
                        // calculate the power value 
                        const measuredPower = (
                                            nodeVoltage[0] * cableCurrent[0] + 
                                            nodeVoltage[1] * cableCurrent[1] + 
                                            nodeVoltage[2] * cableCurrent[2]   ) / 1000
                        // write the sensor value
                        result.addSeries({dynamicId:sStruct.powerMeasurementId,values:[measuredPower]})
                    } 
                }
            }
            
        } catch (error) {
            context.log.write(`Error: ${error}`, Log.level.ERROR)
        }
        
        return result
    }
}

const m = new BifrostZeroModule({
    author         : 'anonymous',
    label          : 'OpenSwarm Asset Simulator',
    about          : 'Module to simulate assest in OpenSwarm PoC1.',
    initCallback   : logic.initFn,
    updateCallback : logic.updateFn,
    fragmentFile   : './data/fragment/Module.Fragment.yaml',
    subscriptions  : [
        TYPEID.VOLTAGE,
        TYPEID.CURRENT,
        TYPEID_LOCAL.CHGSTATION_MAX_POWER,
        TYPEID_LOCAL.PV_SYSTEM_MAX_POWER
    ],
    samplingRate   : 900,
    docURL         : '',
    moduleURL      : process.env.MODULE_URL  || 'http://localhost:1808',
    bifrostURL     : process.env.BIFROST_URL || 'http://localhost:9091',
    hook           : [100, 910]
})

const csvFilePath = 'data/csv/profile-data.csv';
readCSVtoDict(csvFilePath)
    .then(() => {
        m.context.log.write("Data loaded");
    })
    .catch((error) => {
        m.context.log.write('Error reading CSV:', error);
    });

m.start()