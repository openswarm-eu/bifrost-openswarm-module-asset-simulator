/** 
* This template file was generated by the bifrost-sdk.
* Edit the init and update functions to create business logic
for your module. 
*/ 
import  { 
    DataFrame, 
    TModuleContext, 
    TState,
    Log
        } from 'bifrost-zero-common'
import  { 
    CarAssignment,
    CarAssignmentObject,
    CarObj,
    localStorageType,
    TYPEID, 
        } from './src/types.js'
import { config } from './src/config.js'
import  { BifrostZeroModule } from 'bifrost-zero-sdk'
import  { 
    BATTERY_SYSTEM_POWER_MAPPING,
    BATTERY_SYSTEM_MAX_POWER_MAPPING,
    CHARGING_STATION_POWER_MAPPING,
    PV_SYSTEM_POWER_MAPPING,
    sensorDirections,
    sensorNames, 
    TYPEID_LOCAL 
        } from './data/fragment/local_types.js'
import { updateDynamic } from './src/tools.js'
import * as fs from 'fs'
import csv from 'csv-parser'

async function readCSVtoDict(filePath: string): Promise<{ [key: string]: any }> {
    return new Promise((resolve, reject) => {
        fs.createReadStream(filePath)
            .pipe(csv({separator: ";", }))
            .on('data', (row) => {
                const timestamp = row.Time;
                const [hours, minutes, seconds] = timestamp.split(':').map(Number);
                delete row.Time; // Remove the timestamp column from the row object
                const convertedTs = hours*3600 + minutes*60 + seconds
                const numericRow: Record<string, number> = {};
                Object.keys(row).forEach(key => {
                numericRow[key] = parseFloat(row[key]);
                if (isNaN(numericRow[key])) {
                    numericRow[key] = 0; // or any default value, or keep as null/undefined
                }
                });
                csvData[convertedTs] = numericRow;
            })
            .on('end', () => {
                resolve(csvData);
            })
            .on('error', (err) => {
                reject(err);
            });
    });
}

const localStorage : localStorageType = {}
const csvData: { [key: string]: any } = {};
var carAssignmentObject:CarAssignmentObject = {}

const logic = { 

    initFn: (storyId: string, experimentId: string, state: TState, context: TModuleContext) => { 
        
        context.log.write(`Init from [${storyId}/${experimentId}]`)
        
        // initialize the result DataFrame of the init function
        const initResult: DataFrame = new DataFrame()
        initResult.setTime(0)
        
        // initialize the local storage for this experiment
        localStorage[experimentId] = {
            lastUpdate     : -1,
            numberUpdate   : 0,
            allPGCs        : [],
            byPGC          : {},
            allGridSensors : [],
            byGridSensor   : {}
        }
        // initialize struct for EV-STATIONS
        if (carAssignmentObject[experimentId] == undefined){
                carAssignmentObject[experimentId] = [] as CarAssignment
            }
        try {
            for (const structureId of state.structures.ids){
                const entity = state.structures.entities[structureId]
                if(entity.experimentId === experimentId){
                                    
                    // get all needed information for the power grid connectors
                    if(entity.typeId === TYPEID.PGC){
                        localStorage[experimentId].allPGCs.push(structureId)
                        localStorage[experimentId].byPGC[structureId] = {
                            pgcApId   : "",
                            pvApId    : "",
                            pvMaxApId : "",
                            load      : {
                                scaleFactor : 1  // Default load scale factor
                            },
                            solarSystem : {
                                scaleFactor : 1  // Default solar scale factor
                            },
                            evApId    : "",
                            evMaxApId : "",
                            evCharger : {
                                chargingSlots   : 1,  // Default charging slots
                                maxPowerPerSlot : 4,  // Default max power per slot in kW
                                shiftedEnergy   : 0
                            },
                            batteryApId       : "",
                            batteryMaxApId    : "",
                            batterySoCId      : "",
                            batteryCapacityId : "",
                            batterySystem     : {
                                chargePower    : 5,
                                dischargePower : 5,
                                capacity       : 10
                            },
                            parentBuildingId: ""
                        }
                        // to get the ev-station key for the struct
                        const parentBuildingId = state.structures.entities[structureId].parentIds[0]
                        localStorage[experimentId].byPGC[structureId].parentBuildingId = parentBuildingId
                        // init no cars if it is a EV-STATION
                        if (state.structures.entities[parentBuildingId].typeId == TYPEID_LOCAL.EV_STATION){
                            if (carAssignmentObject[experimentId][parentBuildingId] == undefined){
                                let carObj:CarObj = {
                                ecar_assignment_slots_number: 3,
                                ecar_assignment_slots : [],
                                pgc_id: structureId
                                }
                                // init occupation for all slots
                                for(var i = 0; i < 3; i++){
                                    carObj.ecar_assignment_slots.push({ecar_id: -1,
                                                                    charge: 0,
                                                                    charge_max:0,
                                                                    shifted_energy: 0
                                    })
                                }
                                carAssignmentObject[experimentId][parentBuildingId] = carObj
                            }else{
                                carAssignmentObject[experimentId][parentBuildingId].pgc_id = structureId
                            }
                        }

                        // get apId of pgc
                        const pgcDynIds:string[] = entity.dynamicIds
                        for (const dynId of pgcDynIds){
                            if (state.dynamics.entities[dynId].typeId == TYPEID.ACTIVE_POWER){
                                localStorage[experimentId].byPGC[structureId].pgcApId = dynId
                            }
                        }
                        
                        // got through the childs
                        const pgcChildIds:string[] = entity.childIds
                        for (const childId of pgcChildIds){
                            const dynIds = state.structures.entities[childId]?.dynamicIds
                            if (dynIds === undefined){
                                continue
                            }
                            if (state.structures.entities[childId].typeId == TYPEID_LOCAL.SOLAR_PANEL){
                                for (const dynId of dynIds){
                                    if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.PV_SYSTEM_POWER){
                                        localStorage[experimentId].byPGC[structureId].pvApId = dynId
                                    }
                                    if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.PV_SYSTEM_MAX_POWER){
                                        localStorage[experimentId].byPGC[structureId].pvMaxApId = dynId
                                    }
                                }
                            } else if (state.structures.entities[childId].typeId == TYPEID_LOCAL.CHARGING_POLE){
                                for (const dynId of dynIds){
                                    if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.CHGSTATION_POWER){
                                        localStorage[experimentId].byPGC[structureId].evApId = dynId
                                    }
                                    if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.CHGSTATION_MAX_POWER){
                                        localStorage[experimentId].byPGC[structureId].evMaxApId = dynId
                                    }
                                }
                            } else if (state.structures.entities[childId].typeId == TYPEID_LOCAL.BATTERY_SYSTEM){
                                for (const dynId of dynIds){
                                    if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.BATTERY_POWER){
                                        localStorage[experimentId].byPGC[structureId].batteryApId = dynId
                                    }
                                    if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.BATTERY_MAX_POWER){
                                        localStorage[experimentId].byPGC[structureId].batteryMaxApId = dynId
                                    }
                                    if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.BATTERY_SOC){
                                        localStorage[experimentId].byPGC[structureId].batterySoCId = dynId
                                    }
                                    if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.BATTERY_CAPACITY){
                                        localStorage[experimentId].byPGC[structureId].batteryCapacityId = dynId
                                    }
                                }
                            }
                        }

                        // go throught the parents
                        const pgcParentIds:string[] = entity.parentIds
                        for (const parentId of pgcParentIds){
                            // identfiy Solar-Farms
                            if (state.structures.entities[parentId].typeId == TYPEID_LOCAL.SOLAR_FARM){
                                // set the scaleFactor for the solar system simulator to a higher value
                                localStorage[experimentId].byPGC[structureId].solarSystem.scaleFactor = config.structureTypes.solarFarm.solarSystem.scaleFactor
                                // switch off the load simulator for the solar farm
                                localStorage[experimentId].byPGC[structureId].load.scaleFactor = config.structureTypes.solarFarm.load.scaleFactor
                            }
                            // identify EV-Station
                            if (state.structures.entities[parentId].typeId == TYPEID_LOCAL.EV_STATION){
                                // set the scaleFactor for the EV-Charger simulator to a higher value
                                localStorage[experimentId].byPGC[structureId].evCharger.chargingSlots = config.structureTypes.evStation.evCharger.chargingSlots
                                //switch off the load simulator for the EV-Station
                                localStorage[experimentId].byPGC[structureId].load.scaleFactor = config.structureTypes.evStation.load.scaleFactor
                            }
                            // identify Battery-Station
                            if (state.structures.entities[parentId].typeId == TYPEID_LOCAL.BATTERY_STATION){
                                // set the charge and discharge power and capacity to a higher value
                                localStorage[experimentId].byPGC[structureId].batterySystem.chargePower = 10
                                localStorage[experimentId].byPGC[structureId].batterySystem.dischargePower = 10
                                // localStorage[experimentId].byPGC[structureId].batterySystem.capacity = 40
                                // initResult.addSeries({dynamicId:localStorage[experimentId].byPGC[structureId].batteryCapacityId,values:[40]})
                                // switch off the load simulator for the Battery-Station
                                localStorage[experimentId].byPGC[structureId].load.scaleFactor = 0
                            }
                            // is it a small house?
                            if (state.structures.entities[parentId].typeId == TYPEID.SMALL_HOUSE){
                                // set the scaleFactor for the load simulator
                                localStorage[experimentId].byPGC[structureId].load.scaleFactor = config.structureTypes.smallHouse.load.scaleFactor
                            }
                            // is it a huge house?
                            if (state.structures.entities[parentId].typeId == TYPEID.HUGE_HOUSE){
                                // set the scaleFactor for the load simulator
                                localStorage[experimentId].byPGC[structureId].load.scaleFactor = config.structureTypes.hugeHouse.load.scaleFactor
                            }
                        }
                    }

                    // get all needed information for the grid sensors
                    if(entity.typeId === TYPEID_LOCAL.GRID_SENSOR){
                        localStorage[experimentId].allGridSensors.push(structureId)
                        localStorage[experimentId].byGridSensor[structureId] = {
                            nameId               : "",
                            isActive             : true,
                            cablePowerId         : "",
                            powerFlowDirectionId : "",
                            powerMeasurementId   : "",
                            powerLimitId         : ""
                        }
                        // get the sensor dynamicIds
                        const gridDynIds:string[] = entity.dynamicIds
                        for (const dynId of gridDynIds){
                            if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.GRID_SENSOR_NAME){
                                localStorage[experimentId].byGridSensor[structureId].nameId = dynId
                            } else if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.GRID_SENSOR_DIRECTION){
                                localStorage[experimentId].byGridSensor[structureId].powerFlowDirectionId = dynId
                            } else if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.GRID_SENSOR_POWERMEASUREMENT){
                                localStorage[experimentId].byGridSensor[structureId].powerMeasurementId = dynId
                            } else if (state.dynamics.entities[dynId].typeId == TYPEID_LOCAL.GRID_SENSOR_POWERLIMIT){
                                localStorage[experimentId].byGridSensor[structureId].powerLimitId = dynId
                            }
                        }
                        // get now the dynamics of the needed values for calculation of the sensor measurements
                        const parentIds:string[] = entity.parentIds
                        for (const parentId of parentIds){
                            if (state.structures.entities[parentId].typeId == TYPEID.NODE){
                                const nodeEntity = state.structures.entities[parentId]
                                // get the childs of the node
                                const nodeChildIds:string[] = nodeEntity.childIds
                                let cableCounter = 0
                                for (const childId of nodeChildIds){
                                    // skip non connnection entities
                                    if (state.connections.entities[childId] === undefined){
                                        continue
                                    }
                                    if (state.connections.entities[childId].typeId == TYPEID.CABLE){
                                        cableCounter++
                                        if (cableCounter > 2){
                                            // more than 2 cables connected to the node
                                            context.log.write(`Error: More than 2 cables connected to the node ${parentId}`, Log.level.ERROR)
                                            context.log.write(`Sensor ${localStorage[experimentId].byGridSensor[structureId].nameId} set to inactive`, Log.level.INFO)
                                            // set this sensor to inactive
                                            localStorage[experimentId].byGridSensor[structureId].isActive = false
                                            // set the sensor name to "Inactive"
                                            initResult.addSeries({dynamicId:localStorage[experimentId].byGridSensor[structureId].nameId,values:[sensorNames.INACTIVE]})
                                            continue
                                        }
                                        if (cableCounter > 1){
                                            continue
                                        }
                                        // get the cable current id of the cable
                                        const cableEntity = state.connections.entities[childId]
                                        const cableDynIds:string[] = cableEntity.dynamicIds
                                        for (const cableDynId of cableDynIds){
                                            if (state.dynamics.entities[cableDynId].typeId == TYPEID.CABLE_POWER){
                                                localStorage[experimentId].byGridSensor[structureId].cablePowerId = cableDynId
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } catch (error) {
            context.log.write(`Error in init ${error}`, Log.level.ERROR)
        }
        
        return initResult
    },

    updateFn: (storyId: string, experimentId: string, startAt:number, simulationAt: number, replayAt: number, data: DataFrame, context: TModuleContext) => {
        context.log.write(`Update from [${storyId}/${experimentId}] @ ${simulationAt}`)
        // extract subscriptionData out of dataFrame
        var dynamicsById = {}
        if(!data.isEmpty()){
            for (const dynamicObj of data.series) {
                dynamicsById[dynamicObj.dynamicId] = dynamicObj.values[0]
            }
        }
        const result: DataFrame = new DataFrame()
        result.setTime(simulationAt)
        if (localStorage[experimentId].lastUpdate !== simulationAt){
            localStorage[experimentId].lastUpdate = simulationAt
            localStorage[experimentId].numberUpdate = 1
        } else {
            localStorage[experimentId].numberUpdate += 1
        }
        
        try {
            // update asset values
            if (localStorage[experimentId].numberUpdate == 1){
                // give as debug information the hook which is processed here
                context.log.write(`Processing hook ${m.hook[localStorage[experimentId].numberUpdate-1]}`, Log.level.DEBUG)
                let   wData = {};
                //  time modulo so day repeats
                const dataTime = (startAt + simulationAt) % 86400
                // check if the dataTime is in the csvData
                if (!csvData.hasOwnProperty(dataTime)) {
                    // if not, make a linear interpolation
                    const keys = Object.keys(csvData).map(Number).sort((a, b) => a - b);
                    let lowerKey = keys[0];
                    let upperKey = keys[keys.length - 1];
                    for (let i = 0; i < keys.length; i++) {
                        if (keys[i] <= dataTime) {
                            lowerKey = keys[i];
                        }
                        if (keys[i] > dataTime) {
                            upperKey = keys[i];
                            break;
                        }
                    }
                    if (lowerKey === undefined || upperKey === undefined) {
                        context.log.write(`No data available for time ${dataTime}`, Log.level.WARNING);
                        return result; // No data available for this time
                    }
                    // perform linear interpolation
                    const lowerData = csvData[lowerKey];
                    const upperData = csvData[upperKey];
                    const interpolationFactor = (dataTime - lowerKey) / (upperKey - lowerKey);
                    for (const key in lowerData) {
                        if (lowerData.hasOwnProperty(key) && upperData.hasOwnProperty(key)) {
                            wData[key] = lowerData[key] + interpolationFactor * (upperData[key] - lowerData[key]);
                        }
                    }
                } else {
                    wData = csvData[dataTime]
                }
                
                // check, if summer or winter
                let SW = ""
                const SUMMER_START = 6739200;   // ~March 21st in seconds
                const SUMMER_END = 22809600;    // ~September 21st in seconds
                if (startAt > SUMMER_START && startAt < SUMMER_END){
                    SW = "S"
                }else{
                    SW = "W"
                }
                
                for (const pgcId of localStorage[experimentId].allPGCs){
                    const pStruct = localStorage[experimentId].byPGC[pgcId]
                    let sumLoad = 0
                    
                    // add load power
                    let loadPowerResult = wData["LD-"+SW] * pStruct.load.scaleFactor
                    sumLoad += loadPowerResult
                    
                    // add PV power
                    if(pStruct.pvApId){
                        let pvInfeedResult    = [0, 0]
                        let pvInfeedPotential = wData["PV-"+SW] * pStruct.solarSystem.scaleFactor
                        let pvInfeedActual    = pvInfeedPotential
                        
                        if (-pvInfeedPotential > dynamicsById[pStruct.pvMaxApId]){
                            pvInfeedActual = -dynamicsById[pStruct.pvMaxApId]
                        }
                        // write the values to the result DataFrame
                        pvInfeedResult[PV_SYSTEM_POWER_MAPPING.Infeed_Potential] = -pvInfeedPotential
                        pvInfeedResult[PV_SYSTEM_POWER_MAPPING.Actual_Infeed]    = -pvInfeedActual
                        result.addSeries({dynamicId:pStruct.pvApId,values:[pvInfeedResult]})
                        sumLoad += pvInfeedActual
                    }

                    // add EV charging power
                    if(pStruct.evApId){
                        let chgPowerResult  = [0, 0]
                        let chgPowerDemand  = 0
                        let chgPowerActual  = 0
                        let chgPowerShifted = 0
                        let chgPowerLimit   = 0
                        let carStats = config.structureTypes.evStation.carStats
                        const chgPowerList: number[] = []
                        // check if ev-station is in the struct from the mc
                        if (Object.keys(carAssignmentObject[experimentId]).includes(pStruct.parentBuildingId)){
                            const carObj = carAssignmentObject[experimentId][pStruct.parentBuildingId] as CarObj
                            pStruct.evCharger.chargingSlots = carObj.ecar_assignment_slots_number
                            for (const carinSlot of carObj.ecar_assignment_slots){
                                const carId = carinSlot.ecar_id
                                let curCarPower = Number(carStats[carId].carPower)
                                const curCarCharge = carinSlot.charge
                                if (curCarCharge >= carinSlot.charge_max){
                                    curCarPower = 0
                                }
                                chgPowerList.push(curCarPower)
                                chgPowerDemand  += curCarPower
                                chgPowerShifted += curCarPower
                                chgPowerLimit   += pStruct.evCharger.maxPowerPerSlot
                            }
                        }else{
                            // calculate the charging power of each of the charging slots for non-ev-stations
                            for (let i = 0; i < pStruct.evCharger.chargingSlots; i++){
                                chgPowerDemand  += wData["EV"]
                                chgPowerShifted += wData["EV"]
                                chgPowerLimit   += pStruct.evCharger.maxPowerPerSlot
                            }
                        }
                        
                        let chgPowerSetPoint = dynamicsById[pStruct.evMaxApId]
                        pStruct.evCharger.shiftedEnergy += chgPowerShifted - chgPowerSetPoint
                        if (pStruct.evCharger.shiftedEnergy > 0){
                            let newChgPower = chgPowerShifted + pStruct.evCharger.shiftedEnergy
                            if (newChgPower > chgPowerLimit){
                                newChgPower = chgPowerLimit
                            } 
                            // pStruct.evCharger.shiftedEnergy = pStruct.evCharger.shiftedEnergy + chgPowerShifted
                            //pStruct.evCharger.shiftedEnergy = pStruct.evCharger.shiftedEnergy - (newChgPower - chgPowerShifted)
                            chgPowerShifted = newChgPower
                        
                        }
                        // check if the resulting charging power is higher than the max power of the charging station
                        if (chgPowerShifted > chgPowerSetPoint){
                            chgPowerActual = chgPowerSetPoint
                            // pStruct.evCharger.shiftedEnergy += chgPowerShifted - chgPowerSetPoint
                        } else {
                            chgPowerActual = chgPowerShifted
                        }

                        chgPowerResult[CHARGING_STATION_POWER_MAPPING.Power_Demand]   = chgPowerDemand
                        chgPowerResult[CHARGING_STATION_POWER_MAPPING.Actual_Power]   = chgPowerActual
                        chgPowerResult[CHARGING_STATION_POWER_MAPPING.Shifted_Demand] = chgPowerShifted
                        // again, check if it was 
                        if (Object.keys(carAssignmentObject[experimentId]).includes(pStruct.parentBuildingId)){
                            const sumPower = chgPowerList.reduce((acc, current) => acc + current, 0)
                            const partPower = chgPowerActual/sumPower || 1 
                            const carObj = carAssignmentObject[experimentId][pStruct.parentBuildingId] as CarObj
                            // need to reduce the power which can be actually charged for the evcars
                            // if partPower != 1 then it should be reduced
                            for (let i = 0; i < pStruct.evCharger.chargingSlots; i++){
                                const carId = carObj.ecar_assignment_slots[i].ecar_id
                                let curCarPower = Number(carStats[carId].carPower)
                                const chargedPower = chgPowerSetPoint * partPower
                                carObj.ecar_assignment_slots[i].shifted_energy += curCarPower - chargedPower
                                carObj.ecar_assignment_slots[i].charge += chargedPower*m.samplingRate/3600
                            }
                        }
                        result.addSeries({dynamicId:pStruct.evApId,values:[chgPowerResult]})
                        sumLoad += chgPowerActual
                    }

                    // add battery power
                    if(pStruct.batteryApId){
                        let batSocCurrent  = dynamicsById[pStruct.batterySoCId]
                        let batCapacity    = dynamicsById[pStruct.batteryCapacityId]
                        let batPowerLimit  = dynamicsById[pStruct.batteryMaxApId]
                        let batPowerResult = [0, 0, 0]
                        let batPowerActual = 0

                        // calculate the possible charge and discharge power in the current simulation step based on the current SoC and capacity
                        let batPossibleChargePowerSimulationStep = ( batCapacity * ( (100 - batSocCurrent) / 100 )) / ( m.samplingRate / 3600 )
                        if (batPossibleChargePowerSimulationStep > pStruct.batterySystem.chargePower){
                            batPossibleChargePowerSimulationStep = pStruct.batterySystem.chargePower
                        }
                        let batPossibleDischargePowerSimulationStep = ( batCapacity * ( batSocCurrent / 100 )) / (m.samplingRate / 3600)
                        if (batPossibleDischargePowerSimulationStep > pStruct.batterySystem.dischargePower){
                            batPossibleDischargePowerSimulationStep = pStruct.batterySystem.dischargePower
                        }

                        // perform the battery operation based on the given power limits (charge and discharge limits are added up, but it is assumed that one of them is zero.)
                        // Examples: Battery should be charged with 2.5kW:    batPowerLimit = [2.5, 0]  --> results in batPowerActual = 2.5kW
                        //           Battery should be discharged with 3.5kW: batPowerLimit = [0, -3.5] --> results in batPowerActual = -3.5kW
                        // But if both limits are set, then the battery is charged or discharged with the resulting power, which is the sum of both limits.
                        // Example: Battery gets the limits with 2.5kW to charge and 1.5kW to discharge: batPowerLimit = [2.5, -1.5] --> results in batPowerActual = 1kW
                        batPowerActual = batPowerLimit[BATTERY_SYSTEM_MAX_POWER_MAPPING.Charge_Limit] + batPowerLimit[BATTERY_SYSTEM_MAX_POWER_MAPPING.Discharge_Limit]
                        if ((batPowerActual > 0) && (batPowerActual > batPossibleChargePowerSimulationStep)){
                                batPowerActual = batPossibleChargePowerSimulationStep
                        } else if ((batPowerActual < 0) && (Math.abs(batPowerActual) > batPossibleDischargePowerSimulationStep)){
                                batPowerActual = -batPossibleDischargePowerSimulationStep
                        }
                        batPowerResult[BATTERY_SYSTEM_POWER_MAPPING.Actual_Power] = batPowerActual
                        // update the SoC based on the actual power and the capacity
                        if (batCapacity <= 0) {
                            batSocCurrent = 0
                        } else {
                            batSocCurrent += (batPowerActual / batCapacity) * (m.samplingRate / 3600) * 100
                        }
                        
                        // limit the SoC to 0-100%, should only be needed due to numerical errors in the calculations before
                        if (batSocCurrent > 100){
                            batSocCurrent = 100
                        } else if (batSocCurrent < 0){
                            batSocCurrent = 0
                        }

                        // again calculate the possible charge and discharge power, now for the next simulation step based on the altered SoC and capacity
                        batPossibleChargePowerSimulationStep = ( batCapacity * ( (100 - batSocCurrent) / 100 )) / ( m.samplingRate / 3600 )
                        if (batPossibleChargePowerSimulationStep > pStruct.batterySystem.chargePower){
                            batPossibleChargePowerSimulationStep = pStruct.batterySystem.chargePower
                        }
                        batPossibleDischargePowerSimulationStep = ( batCapacity * ( batSocCurrent / 100 )) / (m.samplingRate / 3600)
                        if (batPossibleDischargePowerSimulationStep > pStruct.batterySystem.dischargePower){
                            batPossibleDischargePowerSimulationStep = pStruct.batterySystem.dischargePower
                        }
                        batPowerResult[BATTERY_SYSTEM_POWER_MAPPING.Charge_Potential] = batPossibleChargePowerSimulationStep
                        batPowerResult[BATTERY_SYSTEM_POWER_MAPPING.Discharge_Potential] = -batPossibleDischargePowerSimulationStep

                        result.addSeries({dynamicId:pStruct.batterySoCId,values:[batSocCurrent]})
                        result.addSeries({dynamicId:pStruct.batteryApId,values:[batPowerResult]})
                        sumLoad += batPowerActual
                    }
                    
                    // calculate the resulting load value
                    const resultLoad = (sumLoad/3)
                    result.addSeries({dynamicId:pStruct.pgcApId,values:[[resultLoad,resultLoad,resultLoad]]})
                }
            }
            
            // update the grid sensor values
            if (localStorage[experimentId].numberUpdate == 2){
                context.log.write(`Processing hook ${m.hook[localStorage[experimentId].numberUpdate-1]}`, Log.level.DEBUG)
                for (const sensorId of localStorage[experimentId].allGridSensors){
                    const sStruct = localStorage[experimentId].byGridSensor[sensorId]
                    
                    // if sensor is conected to more than 2 cables, then skip this sensor
                    if (!sStruct.isActive){
                        // set the sensor name to "Inactive"
                        result.addSeries({dynamicId:sStruct.nameId,values:[sensorNames.INACTIVE]})
                        result.addSeries({dynamicId:sStruct.powerMeasurementId,values:[0]})
                        continue
                    }
                    
                    // get the value of the sensor name
                    const sensorName = dynamicsById[sStruct.nameId]
                    if (sensorName == sensorNames.INACTIVE){
                        result.addSeries({dynamicId:sStruct.powerMeasurementId,values:[0]})
                        continue
                    } else { 
                        const cablePower = dynamicsById[sStruct.cablePowerId]
                        
                        // get the power flow scaling factor, which is -1 if powerFlowDirection is "DOWN" and 1 if it is "UP"
                        const powerFlowDirection = dynamicsById[sStruct.powerFlowDirectionId]
                        let powerFlowScalingFactor = 1
                        if (powerFlowDirection === sensorDirections.DOWN){ 
                            powerFlowScalingFactor = -1
                        }
                        
                        // calculate the power value 
                        const measuredPower = powerFlowScalingFactor * (
                                            cablePower[0] + 
                                            cablePower[1] + 
                                            cablePower[2] ) / 3
                        // write the sensor value
                        result.addSeries({dynamicId:sStruct.powerMeasurementId,values:[measuredPower]})
                    } 
                }
            }
            
        } catch (error) {
            context.log.write(`Error: ${error}`, Log.level.ERROR)
        }
        return result
    }
}

const m = new BifrostZeroModule({
    author         : 'anonymous',
    label          : 'OpenSwarm Asset Simulator',
    about          : 'Module to simulate assest in OpenSwarm PoC1.',
    initCallback   : logic.initFn,
    updateCallback : logic.updateFn,
    fragmentFile   : './data/fragment/Module.Fragment.yaml',
    subscriptions  : [
        TYPEID.CABLE_POWER,
        TYPEID_LOCAL.CHGSTATION_MAX_POWER,
        TYPEID_LOCAL.PV_SYSTEM_MAX_POWER,
        TYPEID_LOCAL.BATTERY_SOC,
        TYPEID_LOCAL.BATTERY_CAPACITY,
        TYPEID_LOCAL.BATTERY_MAX_POWER,
        TYPEID_LOCAL.GRID_SENSOR_DIRECTION,
        TYPEID_LOCAL.GRID_SENSOR_NAME
    ],
    samplingRate   : process.env.SAMPLING_RATE ? Number(process.env.SAMPLING_RATE) : 60,
    docURL         : '',
    moduleURL      : process.env.MODULE_URL  || 'http://localhost:7032',
    bifrostURL     : process.env.BIFROST_URL || 'http://localhost:9091',
    hook           : process.env.HOOK ? JSON.parse(process.env.HOOK) : [100, 910]
})


// endpoints accessed by the mc modules
m.app.post("/rest/updateCapacity", async (request, reply) => {
    const body = request.body as object
    try {
            const storyId = body["storyId"]
            const expId = body["experimentId"]
            const dynId = body["dynamicId"]
            const dynVal = parseFloat(body["dynamicValue"])
            const bifrostURL = process.env.BIFROST_URL || 'http://localhost:9091'
            const status = await updateDynamic(bifrostURL, storyId, expId, dynId, dynVal, m.context.log, Log)
            reply.status(status).send(JSON.stringify({
                message: "success"
            }))
    } catch (e) {
        var msg = "Error parsing capacity update"
        m.context.log.write(msg + e, Log.level.ERROR)
        reply.status(400).send(JSON.stringify({
                message: "fail"
            }))
    }
   
})

// should not need file-writing, since everything is in one file/module anyway
m.app.post("/rest/updateCars", (request, reply) => {
            const body = request.body as object
            // get key from object
            const evStationId = Object.keys(body)[0]
            const experimentId = body["expId"][0] as string
            if (carAssignmentObject[experimentId] == undefined){
                carAssignmentObject[experimentId] = [] as CarAssignment
                let carObj:CarObj = {
                                ecar_assignment_slots_number: 3,
                                ecar_assignment_slots : [],
                                pgc_id: ""
                                }
                                // init occupation for all slots
                for(var j = 0; j < 3; j++){
                    carObj.ecar_assignment_slots.push({ecar_id: body[evStationId][j],
                                                    charge: config.structureTypes.evStation.carStats[body[evStationId][j]].carMaxCap*0.15,
                                                    charge_max:config.structureTypes.evStation.carStats[body[evStationId][j]].carMaxCap,
                                                    shifted_energy: 0
                    })
                }
                carAssignmentObject[experimentId][evStationId] = carObj
            }
            m.context.log.write(`experimentId: ${body[evStationId]}`)
            m.context.log.write(`/rest/updateCars for: ${evStationId}`)
            m.context.log.write(`car occupation: ${body[evStationId]}`)
            if(!body[evStationId]){
                reply.status(200).send(JSON.stringify({
                    message: "failure, malformed request"
                }))
                return
            }
            if(!Array.isArray(body[evStationId])){
                reply.status(200).send(JSON.stringify({
                    message: "failure, request is not an array"
                }))
                return
            }
            if(body[evStationId].length < 3){
                reply.status(200).send(JSON.stringify({
                    message: "failure, cannot access array content"
                }))    
                return
            }
            // remove carAssignment for same element, TODO: MAYBE CHANGE IT SO THAT WE CAN SAVE THE CURRENT SOC AND CHARGING STUFF 
            // if (carAssignmentObject[experimentId].length){
            //     for (var evStationKey in Object.keys(carAssignmentObject[experimentId])){
            //         if (evStationKey === evStationId){
            //             // remove this element from array carAssignment
            //             delete carAssignmentObject[experimentId][evStationKey]
            //         }
            //     }
            // }
            const carObj = carAssignmentObject[experimentId][evStationId] as CarObj
            let i = 0
            let slotShiftedSum = 0
            for (const slot of carObj.ecar_assignment_slots){
                // if the car in the slot changed, then reset charge
                if( slot.ecar_id != body[evStationId][i]){
                    slot.ecar_id = body[evStationId][i]
                    slot.charge_max = config.structureTypes.evStation.carStats[body[evStationId][i]].carMaxCap
                    slot.charge = slot.charge_max*0.15
                    if(localStorage[experimentId].byPGC[carObj.pgc_id] != undefined){
                        // reset the shifted energy when it disconnects and also subtract it from the internal struct
                        if(slot.ecar_id == -1){
                            const pStruct = localStorage[experimentId].byPGC[carObj.pgc_id]
                            pStruct.evCharger.shiftedEnergy -= slot.shifted_energy
                            // if there was nothing loaded at all because of no PV
                            slot.shifted_energy = 0
                        }
                    }
                }
                slotShiftedSum += slot.shifted_energy
                i += 1
            }
            if (localStorage[experimentId] != undefined){
                // if there was nothing loaded at all because of no PV, proper reset
                if (slotShiftedSum == 0){
                    localStorage[experimentId].byPGC[carObj.pgc_id].evCharger.shiftedEnergy = 0
                }
            }
        //     let length = 3;
        //     let carObj:CarObj = {
        //         ecar_assignment_slots_number: 3,
        //         ecar_assignment_slots : []
        //     }
        //    // register occupation for all slots
        //     for(var i = 0; i < 3; i++){
        //         carObj.ecar_assignment_slots.push({"ecar_id": parseInt(body[evStationId][i])})
        //     }
        //     if (carAssignmentObject[experimentId].length == 0){
        //         carAssignmentObject[experimentId] = [carObj]
        //     }else{
        //         carAssignmentObject[experimentId][evStationId] = carObj
        //     }
        //     carObj["ecar_assignment_slots_number"] = length
            // try{
            //     m.context.log.write('writing')
            //     fs.writeFileSync(`./data/ev_files/ecar_assignment_${experimentId}.json`, JSON.stringify(carAssignmentObject[experimentId]));
            //     m.context.log.write(`car assignment for experiment ${experimentId} successfully written`)
            // }catch(e){
            //     m.context.log.write(e)
            //     reply.status(200).send(JSON.stringify({
            //         message: "failure, try and catch failure"
            //     }))
            //     return
            // }
            // Reply to the frontend
            reply.status(200).send(JSON.stringify({
                message: "success"
            }))
        });


const csvFilePath = 'data/csv/profile-data.csv';
readCSVtoDict(csvFilePath)
    .then(() => {
        m.context.log.write("CSV Data loaded!");
    })
    .catch((error) => {
        m.context.log.write('Error reading CSV Data:', error);
    });

m.start()