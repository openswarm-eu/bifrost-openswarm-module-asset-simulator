/** 
* This template file was generated by the bifrost-sdk.
* Edit the init and update functions to create business logic
for your module. 
*/ 
import  { 
    DataFrame, 
    TModuleContext, 
    TState 
        } from 'bifrost-zero-common'
import  { 
    localStorageType,
    TYPEID, 
        } from './src/types.js';
import  { BifrostZeroModule } from 'bifrost-zero-sdk'
import  { TYPEID_LOCAL } from './data/fragment/local_types.js';

const localStorage : localStorageType = {}

const logic = { 


    initFn: (storyId: string, experimentId: string, state: TState, context: TModuleContext) => { 
        
        context.log.write(`Init from [${storyId}/${experimentId}]`)
        
        // initialize the local storage for this experiment
        localStorage[experimentId] = {
            loading2StackedLoading: {},
            overlaodingDetection: {}
        }	

        const loadingIds = state.dynamics.ids.filter(entry => entry.includes(TYPEID.LOADING))

        for (const loadingId of loadingIds) {
            const parentId = state.dynamics.entities[loadingId].parentId
            if (parentId.includes(TYPEID.CABLE)) {
                localStorage[experimentId].loading2StackedLoading[loadingId] = {
                    stackedLoadingId: state.connections.entities[parentId].dynamicIds.find(entry => entry.includes(TYPEID_LOCAL.STACKED_LOADING)) || ''
                }
                localStorage[experimentId].overlaodingDetection[loadingId] = {
                    overlaodingTimeId: state.connections.entities[parentId].dynamicIds.find(entry => entry.includes(TYPEID_LOCAL.OVERLAODED_TIME)) || '',
                    checkedLastTime: 0,
                    overloading070Time: 0,
                    overloading100Time: 0
                }
            } else if (parentId.includes(TYPEID.TRANSFORMER)) {
                localStorage[experimentId].loading2StackedLoading[loadingId] = {
                    stackedLoadingId: state.structures.entities[parentId].dynamicIds.find(entry => entry.includes(TYPEID_LOCAL.STACKED_LOADING)) || ''
                }
                localStorage[experimentId].overlaodingDetection[loadingId] = {
                    overlaodingTimeId: state.structures.entities[parentId].dynamicIds.find(entry => entry.includes(TYPEID_LOCAL.OVERLAODED_TIME)) || '',
                    checkedLastTime: 0,
                    overloading070Time: 0,
                    overloading100Time: 0
                }
            }
            
        }
        
        return new DataFrame()
    },

    updateFn: (storyId: string, experimentId: string, startAt:number, simulationAt: number, replayAt: number, data: DataFrame, context: TModuleContext) => {
        
        context.log.write(`Update from [${storyId}/${experimentId}] @ ${simulationAt}`)

        const result: DataFrame = new DataFrame()
        result.setTime(simulationAt)

        for (const seriesElement of data.series) {
            const loadingValue = seriesElement.values[0][0]
            const loadingId = seriesElement.dynamicId
            const stackedLoadingId = localStorage[experimentId].loading2StackedLoading[loadingId].stackedLoadingId
            const overlaodingTimeId = localStorage[experimentId].overlaodingDetection[loadingId].overlaodingTimeId
            const overloadingCheckedLastTime = localStorage[experimentId].overlaodingDetection[loadingId].checkedLastTime
            var   overloading070Time = localStorage[experimentId].overlaodingDetection[loadingId].overloading070Time
            var   overloading100Time = localStorage[experimentId].overlaodingDetection[loadingId].overloading100Time
            const stackedLoadingValue = [0 , 0 , 0 ]
            
            if ( loadingValue <= 70) {
                stackedLoadingValue[0] = loadingValue
            } else if ((loadingValue >= 70) && (loadingValue < 100)) {
                stackedLoadingValue[0] = 70
                stackedLoadingValue[1] = loadingValue - 70
                overloading070Time += (simulationAt - overloadingCheckedLastTime) / 3600
            } else {
                stackedLoadingValue[0] = 70
                stackedLoadingValue[1] = 30
                stackedLoadingValue[2] = loadingValue - 100
                overloading070Time += (simulationAt - overloadingCheckedLastTime) / 3600
                overloading100Time += (simulationAt - overloadingCheckedLastTime) / 3600
                
            }

            localStorage[experimentId].overlaodingDetection[loadingId].checkedLastTime = simulationAt
            localStorage[experimentId].overlaodingDetection[loadingId].overloading070Time = overloading070Time
            localStorage[experimentId].overlaodingDetection[loadingId].overloading100Time = overloading100Time

            result.addSeries({dynamicId: stackedLoadingId,  values: [stackedLoadingValue]})
            result.addSeries({dynamicId: overlaodingTimeId, values: [[overloading100Time, overloading070Time]]})
        }
        
        return result
    }
}

const m = new BifrostZeroModule({
    author         : 'anonymous',
    label          : 'SiEmergy Analysis Module',
    about          : 'Module to provide additional analysis for SiEmergy project.',
    initCallback   : logic.initFn,
    updateCallback : logic.updateFn,
    fragmentFile   : './data/fragment/ProSeCO.Fragment.yaml',
    subscriptions  : [
        TYPEID.LOADING
    ],
    samplingRate   : 900,
    docURL         : '',
    moduleURL      : process.env.MODULE_URL  || 'http://localhost:1809',
    bifrostURL     : process.env.BIFROST_URL || 'http://localhost:9091',
    hook           : [100]
})
m.start()