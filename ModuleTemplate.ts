/** 
* This template file was generated by the bifrost-sdk.
* Edit the init and update functions to create business logic
for your module. 
*/ 
import  { 
    DataFrame, 
    TModuleContext, 
    TState 
        } from 'bifrost-zero-common'
import  { 
    Dictionary, 
    localStorageType, 
    occupancyStructType 
        } from './src/types.js';
import  { BifrostZeroModule } from 'bifrost-zero-sdk'
import  { TYPEID_LOCAL } from './data/fragment/local_types.js';
import  { generators } from './src/tools.js';

const localStorage : localStorageType = {}

const logic = { 

    noiseLevelDynamics     : {} as Dictionary<string[]>,
    politicalModelDynamics : {} as Dictionary<string[]>,
    occupancyStruct        : {} as Dictionary<occupancyStructType>,
    politicalModelEnums    : {},
    generateNoiseLevel     : true,
    generatePoliticalModel : true,
    generateOccupancy      : true,
    flowRevenueDynamics    : {} as Dictionary<string[]>,
    flowEnergyDynamics     : {} as Dictionary<string[]>,
    flowPeopleDynamics     : {} as Dictionary<string[]>,

    // Insert expensive setup calculations and static state query expressions here.
    // Store the instance IDs of the dynamics this module and
    // provide locally this information for later use during the update function.
    initFn: (storyId: string, experimentId: string, state: TState, context: TModuleContext) => { 
        
        context.log.write(`Init from [${storyId}/${experimentId}]`)
        
        // initialize the local storage for this experiment
        localStorage[experimentId] = {
            noiseLevelDynamics: [],
            politicalModelDynamics: [],
            occupancyStruct: { ids: [], min: 0, max: 0 }
        }	
        
        localStorage[experimentId].noiseLevelDynamics = state.dynamics.ids.filter(entry => entry.includes(TYPEID_LOCAL.AMBIENT_NOISE_LEVEL))
        localStorage[experimentId].politicalModelDynamics = state.dynamics.ids.filter(entry => entry.includes(TYPEID_LOCAL.POLITICAL_MODEL))
        logic.politicalModelEnums = state.directory.dynamics.entities[TYPEID_LOCAL.POLITICAL_MODEL].schema.enum
        localStorage[experimentId].occupancyStruct = { 
            ids: state.dynamics.ids.filter(entry => entry.includes(TYPEID_LOCAL.OCCUPANCY)), 
            min: state.directory.dynamics.entities[TYPEID_LOCAL.OCCUPANCY].schema.items.minimum, 
            max: state.directory.dynamics.entities[TYPEID_LOCAL.OCCUPANCY].schema.items.maximum 
        }
        
        return new DataFrame()
    },
    updateFn: (storyId: string, experimentId: string, startAt:number, simulationAt: number, replayAt: number, data: DataFrame, context: TModuleContext) => {
        
        context.log.write(`\nUpdate from [${storyId}/${experimentId}] @ ${simulationAt}`)
        
        const result: DataFrame = new DataFrame()
        result.setTime(simulationAt)
        
        // Insert your module update logic here.
        // Generate some random data values and add them as time series to the DataFrame result
        if(logic.generateNoiseLevel) {
            for (const dynamicId of localStorage[experimentId].noiseLevelDynamics) {
                result.addSeries({dynamicId, values: [generators.randFloat()]})
            }
        }
        if (logic.generatePoliticalModel) {
            for (const dynamicId of localStorage[experimentId].politicalModelDynamics) {
                result.addSeries({dynamicId, values:[generators.pickStr(logic.politicalModelEnums as string[])]})
            } 
        }
        if (logic.generateOccupancy) {
            const occupancyStruct = localStorage[experimentId].occupancyStruct
            for (const dynamicId of occupancyStruct.ids) {
                result.addSeries({dynamicId, values: 
                    [[
                    generators.randInt(occupancyStruct.min,occupancyStruct.max),
                    generators.randInt(occupancyStruct.min,occupancyStruct.max),
                    generators.randInt(occupancyStruct.min,occupancyStruct.max),
                    generators.randInt(occupancyStruct.min,occupancyStruct.max)
                ]]})
            }
        }

    // Use the subscriptions and add something to the flow dynamics
    if (!data.isEmpty()) {
        for (const seriesElement of data.series) {
            switch (seriesElement.meta.typeId) {
                case TYPEID_LOCAL.FLOW_REVENUE:
                    let rvalue = seriesElement.values[0] as number
                    if (simulationAt % 5 === 0) {
                        rvalue = generators.clamp(generators.inc(rvalue, 0.01), [-1, 1])
                        if (rvalue >= 1) {
                            rvalue = -1
                        }
                    }
                    result.addSeries({ dynamicId: seriesElement.dynamicId, values: [rvalue] })
                    break
                case TYPEID_LOCAL.FLOW_ENERGY:
                    let evalue = seriesElement.values[0] as number
                    if (simulationAt % 10 === 0) {
                        evalue = generators.clamp(generators.inc(evalue, 0.01), [-1, 1])
                        if (evalue >= 1) {
                            evalue = -1
                        }
                    }
                    result.addSeries({ dynamicId: seriesElement.dynamicId, values: [evalue] })
                    break
                case TYPEID_LOCAL.FLOW_PEOPLE:
                    let pvalue = seriesElement.values[0] as number
                    if (simulationAt % 15 === 0) {
                        pvalue = generators.clamp(generators.inc(pvalue, 0.01), [-1, 1])
                        if (pvalue >= 1) {
                            pvalue = -1
                        }
                    }
                    result.addSeries({ dynamicId: seriesElement.dynamicId, values: [pvalue] })
                    break
                default:
                    break
            }
        }
    }
        return result
    }
}

const m = new BifrostZeroModule({
    author         : 'anonymous',
    label          : 'ModuleTemplate',
    about          : 'ZERO Module Template',
    initCallback   : logic.initFn,
    updateCallback : logic.updateFn,
    fragmentFile   : './data/fragment/ModuleTemplate.Fragment.yaml',
    subscriptions  : [
        TYPEID_LOCAL.FLOW_REVENUE, TYPEID_LOCAL.FLOW_ENERGY, TYPEID_LOCAL.FLOW_PEOPLE
    ],
    samplingRate   : 900,
    docURL         : '',
    moduleURL      : process.env.MODULE_URL  || 'http://localhost:1809',
    bifrostURL     : process.env.BIFROST_URL || 'http://localhost:9091',
    hook           : [100]
})
m.start()