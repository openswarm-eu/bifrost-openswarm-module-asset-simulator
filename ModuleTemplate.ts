/** 
* This template file was generated by the bifrost-sdk.
* Edit the init and update functions to create business logic
for your module. 
*/ 
import  { 
    DataFrame, 
    TModuleContext, 
    TState 
        } from 'bifrost-zero-common'
import  { 
    Dictionary, 
    oStruct 
        } from './src/types.js';
import  { BifrostZeroModule } from 'bifrost-zero-sdk'
import  { TYPEID_LOCAL } from './data/fragment/local_types.js';
import  { generators } from './src/tools.js';

const logic = { 

    noiseLevelDynamics     : {} as Dictionary<string[]>,
    politicalModelDynamics : {} as Dictionary<string[]>,
    occupancyStruct        : {} as Dictionary<oStruct>,
    politicalModelEnums    : {},
    generateNoiseLevel     : true,
    generatePoliticalModel : true,
    generateOccupancy      : true,
    flowRevenueDynamics    : {} as Dictionary<string[]>,
    flowEnergyDynamics     : {} as Dictionary<string[]>,
    flowPeopleDynamics     : {} as Dictionary<string[]>,

    initFn: (storyId: string, experimentId: string, state: TState, context: TModuleContext) => { 
        context.log.write(`Init from [${storyId}/${experimentId}]`)
        // Insert expensive setup calculations and static state query expressions here.
        // Store the instance IDs of the dynamics this module
        // provides locally for later access during the update function.
        logic.noiseLevelDynamics[experimentId] = state.dynamics.ids.filter(entry => entry.includes(TYPEID_LOCAL.AMBIENT_NOISE_LEVEL))
        logic.politicalModelDynamics[experimentId] = state.dynamics.ids.filter(entry => entry.includes(TYPEID_LOCAL.POLITICAL_MODEL))
        logic.politicalModelEnums = state.directory.dynamics.entities[TYPEID_LOCAL.POLITICAL_MODEL].schema.enum
        const occupancyIds = state.dynamics.ids.filter(entry => entry.includes(TYPEID_LOCAL.OCCUPANCY))
        const occuMinMax = state.directory.dynamics.entities[TYPEID_LOCAL.OCCUPANCY].schema.items
        logic.occupancyStruct[experimentId] = { ids: occupancyIds, min: occuMinMax.minimum, max: occuMinMax.maximum }
        
        return new DataFrame()
    },
    updateFn: (storyId: string, experimentId: string, startAt:number, simulationAt: number, replayAt: number, data: DataFrame, context: TModuleContext) => {
        context.log.write(`\nUpdate from [${storyId}/${experimentId}] @ ${simulationAt}`)
        const result: DataFrame = new DataFrame()
        result.setTime(simulationAt)
        // Insert your module update logic here.
        // Generate some random data values and add them as time series to the DataFrame result
        if(logic.generateNoiseLevel) {
            for (const dynamicId of logic.noiseLevelDynamics[experimentId]) {
                result.addSeries({dynamicId, values: [generators.randFloat()]})
            }
        }
        if (logic.generatePoliticalModel) {
            for (const dynamicId of logic.politicalModelDynamics[experimentId]) {
                result.addSeries({dynamicId, values:[generators.pickStr(logic.politicalModelEnums as string[])]})
            } 
        }
        if (logic.generateOccupancy) {
            const occupancyStruct = logic.occupancyStruct[experimentId]
            for (const dynamicId of occupancyStruct.ids) {
                result.addSeries({dynamicId, values: [[generators.randInt(occupancyStruct.min,occupancyStruct.max),
                                                       generators.randInt(occupancyStruct.min,occupancyStruct.max),
                                                       generators.randInt(occupancyStruct.min,occupancyStruct.max),
                                                       generators.randInt(occupancyStruct.min,occupancyStruct.max)]]})
            }
        }

    // Use the subscriptions and add something to the flow dynamics
    if (!data.isEmpty()) {
        for (const seriesElement of data.series) {
            switch (seriesElement.meta.typeId) {
                case TYPEID_LOCAL.FLOW_REVENUE:
                    let rvalue = seriesElement.values[0] as number
                    if (simulationAt % 5 === 0) {
                        rvalue = generators.clamp(generators.inc(rvalue, 0.1), [-1, 1])
                    }
                    result.addSeries({ dynamicId: seriesElement.dynamicId, values: [rvalue] })
                    break
                case TYPEID_LOCAL.FLOW_ENERGY:
                    let evalue = seriesElement.values[0] as number
                    if (simulationAt % 10 === 0) {
                        evalue = generators.clamp(generators.inc(evalue, 0.1), [-1, 1])
                    }
                    result.addSeries({ dynamicId: seriesElement.dynamicId, values: [evalue] })
                    break
                case TYPEID_LOCAL.FLOW_PEOPLE:
                    let pvalue = seriesElement.values[0] as number
                    if (simulationAt % 15 === 0) {
                        pvalue = generators.clamp(generators.inc(pvalue, 0.1), [-1, 1])
                    }
                    result.addSeries({ dynamicId: seriesElement.dynamicId, values: [pvalue] })
                    break
                default:
                    break
            }
        }
    }
        return result
    }
}

const m = new BifrostZeroModule({
    author         : 'anonymous',
    label          : 'ModuleTemplate',
    about          : 'ZERO Module Template',
    initCallback   : logic.initFn,
    updateCallback : logic.updateFn,
    fragmentFile   : './data/fragment/ModuleTemplate.Fragment.yaml',
    subscriptions  : [
        TYPEID_LOCAL.FLOW_REVENUE, TYPEID_LOCAL.FLOW_ENERGY, TYPEID_LOCAL.FLOW_PEOPLE
    ],
    samplingRate   : 900,
    docURL         : '',
    moduleURL      : process.env.MODULE_URL  || 'http://localhost:1809',
    bifrostURL     : process.env.BIFROST_URL || 'http://localhost:9091',
    hook           : [100]
})
m.start()